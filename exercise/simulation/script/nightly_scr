#!/usr/bin/env ruby

# ----- setup -----

Dir.chdir File.expand_path(__dir__)
require_relative '../../Base/lib/dotenv'
TRIAL_DIR = dotenv_trial_dir(__dir__)

# ----- libraries -----

require_relative '../../Base/lib/exchange'
require_relative '../../Base/lib/trial_settings'
require 'awesome_print'
require 'securerandom'
# require ./user_gen_scr_setting
require 'yaml'
require_relative "./../webapp/app_helpers"
require 'open-uri'  # for downloading grafana image
# make function for graph1
AppHelpers.module_eval do
  module_function(:fixed_total_graph)
  public :fixed_total_graph
end

#require 'whenever'
# ----- info -----

puts "EXCHANGE_DIR=#{Exchange.src_dir}"
#puts 'EXERCISE SETTINGS'
#ap TrialSettings.settings

# ----- load -----

puts 'LOADING RAILS'
Exchange.load_rails


@nightly_run = Time.now - 1
def nightly_scr
  # ----- read settings -----

  settings = YAML.load_file('nightly_scr_setting.yml')
  # settings_issue_gen = YAML.load_file('issue_gen_scr_setting.yml')
  # settings_skill = YAML.load_file('skill.yml')
  # run again next:
  # Wait time before switching day
  puts "current run #{@nightly_run} < current time #{Time.now}"
  @nightly_run += settings['seconds_for_day_switching']

  puts "next run #{@nightly_run} > current time #{Time.now}"
  # ----- accounts -----
  puts 'Running Nightly script'

  # Setting BugmTime in past
  # TODO: move to a separate script, not part of the nightly logic
  # if settings['running_script_first_time'] == 1
  #   puts "set server in past for first time"
  #   new_val = 0
  #   hours = 0
  #   File.open("/tmp/bugm_day_jump", 'w') {|f| f.puts new_val}
  #   File.open("/tmp/bugm_hour_jump", 'w') {|f| f.puts hours}
  #   BugmTime.set_day_offset(-1 * settings['time_back_days_start'])
  # else
  #   puts "set server time to continue from last run"
  #   time_back_days = (Time.now.to_date - settings['closing_bugmtime'].to_date).round - 1
  #   BugmTime.set_day_offset(-1 * time_back_days)
  #   settings['days_passed_after_session'] += 1
  # end
  # counter = settings['time_back_days_start']

  # Running the loop for time and different scripts
  # for i in settings['days_passed_after_session']..counter
    # puts counter
    # puts i
    # puts settings['days_passed_after_session']
    # Change day
    STDOUT.write "\rStep 1: go past end of day                                  "
    STDOUT.flush
    last_day = BugmTime.now
    BugmTime.go_past_end_of_day

    # resolve mature contracts
    STDOUT.write "\rStep 2: resolve matured contracts                           "
    STDOUT.flush
    Contract.pending_resolution.each do |contract|
         ContractCmd::Resolve.new(contract).project
    end

    # Expire expired offers
    STDOUT.write "\rStep 3: expire expired offers                               "
    STDOUT.flush
    Offer.open.expired_by_time.each do |offer|
      offer.update_attribute(:status, 'expired')
    end

    # Generate new issues
    # id =1
    # id = Issue.last.id unless Issue.last.nil?
    # Tracker.all.each do |i|
    #   settings_issue_gen['number_of_issues_tracker'].times do
    #     id = id+1
    #     opts = {
    #       stm_title: SecureRandom.hex(2),
    #       stm_tracker_uuid: i.uuid,
    #       stm_status: 'open',
    #       stm_body: ' ',
    #       exid: id
    #     }
    #     issueid = FB.create(:issue, opts).issue.id
    #     skill_array = settings_skill['skills'].sample(settings_issue_gen['number_of_skills_issue'])
    #     myhash = {"skill"=> {}}
    #     skill_array.each do |i|
    #       myhash["skill"]["#{i}"] = 0
    #     end
    #     sql = "UPDATE issues SET jfields = '#{JSON.generate(myhash)}' WHERE id='#{issueid}';"
    #     ActiveRecord::Base.connection.execute(sql).to_a
    #   end
    # end

    #Store the days passed after the last session and timestamp
    STDOUT.write "\rStep 4: store in file progress of simulation                "
    STDOUT.flush
    settings['days_passed_after_session'] += 1
    settings['closing_bugmtime'] = BugmTime.now
    settings['closing_timestamp'] = Time.now
    File.open('nightly_scr_setting.yml', 'w') {|f| f.write settings.to_yaml}

    # # Breaking the scripts
    # trap("SIGINT") { throw :ctrl_c }
    #
    # catch :ctrl_c do
    #   begin
    #     settings['days_passed_after_session'] =  settings['time_back_days'] - (Time.now.to_date - BugmTime.now.to_date).round
    #     File.open('nightly_scr_setting.yml', 'w') {|f| f.write settings.to_yaml}
    #   rescue Exception
    #     puts "Values stored"
    #   end
    # end

    #Generate Data for graph
    STDOUT.write "\rStep 5: generate data for graphs                            "
    STDOUT.flush
    # Extracting data for graphs
    AppHelpers.fixed_total_graph(last_day)

    STDOUT.write "\rStep 6: create graphs                                       "
    STDOUT.flush
    # contract fix rate
    open('./../webapp/public/graph/contract_fix_rate.png', 'wb') do |file|
      file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=2&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=500&height=250&tz=UTC-05%3A00").read
    end
    # payout vs potential
    open('./../webapp/public/graph/payout_vs_potential.png', 'wb') do |file|
      file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=4&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=500&height=250&tz=UTC-05%3A00").read
    end
    # variance of offer volumes
    open('./../webapp/public/graph/var_offer_volumes.png', 'wb') do |file|
      file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=6&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=500&height=250&tz=UTC-05%3A00").read
    end
    # open offer count and volume
    open('./../webapp/public/graph/open_offer_count_vol.png', 'wb') do |file|
      file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=8&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=500&height=250&tz=UTC-05%3A00").read
    end


    STDOUT.write "\r                                                            "
    STDOUT.flush
    puts "current day (#{BugmTime.now}), next day in #{settings['seconds_for_day_switching']} seconds"
  # end
end

def workqueue_sync
  un_marked_list_sql = "Select id, issue_uuid, task from work_queues
    where updated_issue = false
    and completed < now()
    and (removed > completed OR removed IS NULL); "
  un_marked_lists = ActiveRecord::Base.connection.execute(un_marked_list_sql).to_a

  # Update Issue table J-field for issue/task completed
  updated_ids = []
  un_marked_lists.each do |i|
    updated_ids.push(i['id'])
    puts i["issue_uuid"]
    issue_update = "UPDATE issues
    SET jfields = replace(jfields::TEXT, '\"#{i["task"]}\": 0','\"#{i["task"]}\": 1')::jsonb
    WHERE uuid='#{i["issue_uuid"]}'
    ;"
    #binding.pry
    ActiveRecord::Base.connection.execute(issue_update)
    task_completed = Issue.where(uuid: "#{i["issue_uuid"]}").first.jfields["skill"]
    ex_id = Issue.where(uuid: "#{i["issue_uuid"]}").first.exid
    check = true
    # Check all the skills of an issue are worked on and mark it closed
    task_completed.each do |key, value|
      if value == 0
        check = false
      end
    end
    if check == true
      IssueCmd::Sync.new({exid: ex_id, stm_status: "closed"}).project
    end
  end
  if updated_ids.length > 0
    work_queue_update_sql = "update work_queues SET updated_issue = TRUE WHERE id IN (#{updated_ids * ","});"
    ActiveRecord::Base.connection.execute(work_queue_update_sql)
  end
end

loop do
  workqueue_sync
  if @nightly_run <= Time.now
    nightly_scr
  end
  sleep 1
end

puts 'DONE'
