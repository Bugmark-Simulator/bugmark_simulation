#!/usr/bin/env ruby

# ----- setup -----

Dir.chdir File.expand_path(__dir__)
require_relative '../../Base/lib/dotenv'
TRIAL_DIR = dotenv_trial_dir(__dir__)

# ----- libraries -----

require_relative '../../Base/lib/exchange'
require_relative '../../Base/lib/trial_settings'
require 'awesome_print'
require 'securerandom'
# require ./user_gen_scr_setting
require 'yaml'
require_relative "./../webapp/app_helpers"
require 'open-uri'  # for downloading grafana image
# make function for graph1
AppHelpers.module_eval do
  module_function(:grafana_graph_data)
  public :grafana_graph_data
end

#require 'whenever'
# ----- info -----

puts "EXCHANGE_DIR=#{Exchange.src_dir}"
#puts 'EXERCISE SETTINGS'
#ap TrialSettings.settings

# ----- load -----

puts 'LOADING RAILS'
Exchange.load_rails


@nightly_run = Time.now - 1
@request_graph_pictures = false;
@getting_graph_pictures = false;


sql = "INSERT INTO bugmtimes (bugmtime, systime) VALUES ('#{BugmTime.now.utc.strftime('%Y-%m-%d %H:%M:%S.%L')}', '#{Time.now.utc.strftime('%Y-%m-%d %H:%M:%S.%L')}');"
ActiveRecord::Base.connection.execute(sql)


def nightly_scr
  # ----- read settings -----

  # settings = YAML.load_file('nightly_scr_setting.yml')
  # settings_issue_gen = YAML.load_file('issue_gen_scr_setting.yml')
  # settings_skill = YAML.load_file('skill.yml')
  # run again next:
  @graph_size_width = 500
  @graph_size_height = 180

  # Wait time before switching day
  puts "current run #{@nightly_run} < current time #{Time.now}"
  @nightly_run += TS.nightly_scr["seconds_for_day_switching"]

  puts "next run #{@nightly_run} > current time #{Time.now}"
  # ----- accounts -----
  puts 'Running Nightly script'

  # Setting BugmTime in past
  # TODO: move to a separate script, not part of the nightly logic
  # if settings['running_script_first_time'] == 1
  #   puts "set server in past for first time"
  #   new_val = 0
  #   hours = 0
  #   File.open("/tmp/bugm_day_jump", 'w') {|f| f.puts new_val}
  #   File.open("/tmp/bugm_hour_jump", 'w') {|f| f.puts hours}
  #   BugmTime.set_day_offset(-1 * settings['time_back_days_start'])
  # else
  #   puts "set server time to continue from last run"
  #   time_back_days = (Time.now.to_date - settings['closing_bugmtime'].to_date).round - 1
  #   BugmTime.set_day_offset(-1 * time_back_days)
  #   settings['days_passed_after_session'] += 1
  # end
  # counter = settings['time_back_days_start']

  # Running the loop for time and different scripts
  # for i in settings['days_passed_after_session']..counter
    # puts counter
    # puts i
    # puts settings['days_passed_after_session']
    # Change day
    STDOUT.write "\rStep 1: go past end of day                                  "
    STDOUT.flush
    last_day = BugmTime.now
    BugmTime.go_past_end_of_day
    sql = "INSERT INTO bugmtimes (bugmtime, systime) VALUES ('#{BugmTime.now.utc.strftime('%Y-%m-%d %H:%M:%S.%L')}', '#{Time.now.utc.strftime('%Y-%m-%d %H:%M:%S.%L')}');"
    ActiveRecord::Base.connection.execute(sql)


    # resolve mature contracts
    STDOUT.write "\rStep 2: resolve matured contracts                           "
    STDOUT.flush
    Contract.pending_resolution.each do |contract|
         ContractCmd::Resolve.new(contract).project
    end

    # Expire expired offers
    STDOUT.write "\rStep 3: expire expired offers                               "
    STDOUT.flush
    Offer.open.expired_by_time.each do |offer|
      offer.update_attribute(:status, 'expired')
    end

    # Generate new issues
    # id =1
    # id = Issue.last.id unless Issue.last.nil?
    # Tracker.all.each do |i|
    #   settings_issue_gen['number_of_issues_tracker'].times do
    #     id = id+1
    #     opts = {
    #       stm_title: SecureRandom.hex(2),
    #       stm_tracker_uuid: i.uuid,
    #       stm_status: 'open',
    #       stm_body: ' ',
    #       exid: id
    #     }
    #     issueid = FB.create(:issue, opts).issue.id
    #     skill_array = settings_skill['skills'].sample(settings_issue_gen['number_of_skills_issue'])
    #     myhash = {"skill"=> {}}
    #     skill_array.each do |i|
    #       myhash["skill"]["#{i}"] = 0
    #     end
    #     sql = "UPDATE issues SET jfields = '#{JSON.generate(myhash)}' WHERE id='#{issueid}';"
    #     ActiveRecord::Base.connection.execute(sql).to_a
    #   end
    # end

    #Store the days passed after the last session and timestamp
    # STDOUT.write "\rStep 4: store in file progress of simulation                "
    # STDOUT.flush
    # settings['days_passed_after_session'] += 1
    # settings['closing_bugmtime'] = BugmTime.now
    # settings['closing_timestamp'] = Time.now
    # File.open('nightly_scr_setting.yml', 'w') {|f| f.write settings.to_yaml}

    # # Breaking the scripts
    # trap("SIGINT") { throw :ctrl_c }
    #
    # catch :ctrl_c do
    #   begin
    #     settings['days_passed_after_session'] =  settings['time_back_days'] - (Time.now.to_date - BugmTime.now.to_date).round
    #     File.open('nightly_scr_setting.yml', 'w') {|f| f.write settings.to_yaml}
    #   rescue Exception
    #     puts "Values stored"
    #   end
    # end

    #Generate Data for graph
    STDOUT.write "\rStep 5: generate data for graphs                            "
    STDOUT.flush
    # Extracting data for graphs
    AppHelpers.grafana_graph_data(last_day)


    STDOUT.write "\rStep 6: create graphs                                       "
    STDOUT.flush
    @request_graph_pictures = true;


    STDOUT.write "\r                                                            "
    STDOUT.flush
    puts "current day (#{BugmTime.now}), next day in #{TS.nightly_scr["seconds_for_day_switching"]} seconds"
  # end
end

def workqueue_sync
  un_marked_list_sql = "Select id, issue_uuid, task from work_queues
    where updated_issue = false
    and completed < now()
    and (removed > completed OR removed IS NULL); "
  un_marked_lists = ActiveRecord::Base.connection.execute(un_marked_list_sql).to_a

  # Update Issue table J-field for issue/task completed
  updated_ids = []
  un_marked_lists.each do |i|
    updated_ids.push(i['id'])
    # puts i["issue_uuid"]
    issue_update = "UPDATE issues
    SET jfields = replace(jfields::TEXT, '\"#{i["task"]}\": 0','\"#{i["task"]}\": 1')::jsonb
    WHERE uuid='#{i["issue_uuid"]}'
    ;"
    issue_update_sql = "update issues
        set jfields = jsonb_set(jfields, '{\"first_activity\"}', jsonb '\"#{BugmTime.now.strftime("%Y-%m-%d")}\"')
        WHERE uuid = '#{i["issue_uuid"]}'
        AND jfields->>'first_activity' = '';"
    ActiveRecord::Base.connection.execute(issue_update_sql)
    issue_update_sql = "update issues
            set jfields = jsonb_set(jfields, '{\"last_activity\"}', jsonb '\"#{BugmTime.now.strftime("%Y-%m-%d")}\"')
            WHERE uuid = '#{i["issue_uuid"]}';"
    ActiveRecord::Base.connection.execute(issue_update_sql)

    #binding.pry
    ActiveRecord::Base.connection.execute(issue_update)
    task_completed = Issue.where(uuid: "#{i["issue_uuid"]}").first.jfields["skill"]
    ex_id = Issue.where(uuid: "#{i["issue_uuid"]}").first.exid
    check = true
    # Check all the skills of an issue are worked on and mark it closed
    task_completed.each do |key, value|
      if value == 0
        check = false
      end
    end

    if check == true
      IssueCmd::Sync.new({exid: ex_id, stm_status: "closed"}).project
      issue_update_sql = "update issues
              set jfields = jsonb_set(jfields, '{\"closed_on\"}', jsonb '\"#{BugmTime.now.strftime("%Y-%m-%d")}\"')
              WHERE exid = '#{ex_id}';"
      ActiveRecord::Base.connection.execute(issue_update_sql)
    end
  end
  if updated_ids.length > 0
    work_queue_update_sql = "update work_queues SET updated_issue = TRUE WHERE id IN (#{updated_ids * ","});"
    ActiveRecord::Base.connection.execute(work_queue_update_sql)
  end
end

def update_graphs
  # only get graphs if they were requested
  return unless @request_graph_pictures
  # only get graphs, if the process is not yet running
  return if @getting_graph_pictures
  # announce that the process is running
  @getting_graph_pictures = true
  # reset requeest bit
  @request_graph_pictures = false

  STDOUT.puts "\rStep 6: store graphs in static files                            "
  Tracker.pluck('uuid').shuffle.each do |project_uuid|
    puts "graphs for project #{Tracker.where(uuid: project_uuid).first.name}"
    # get all pictures for this project at the same time
    threads = []
    threads.push(
      # contract fix rate
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_contract_fix_rate.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=2&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        # puts "graph: 1 - contract fix rate"
      end
    )
    # payout vs potential
    threads.push(
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_payout_vs_potential.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=4&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        # puts "graph: 2 - payout vs potential"
      end
    )
    # variance of offer volumes
    threads.push(
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_var_offer_volumes.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=6&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        # puts "graph: 3 - variance of offer volumes"
      end
    )
    # open offer count and volume
    threads.push(
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_open_offer_count_vol.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=8&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        # puts "graph: 4 - open offer count and volume"
      end
    )
    # maturation days offers summary
    threads.push(
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_maturation_days_offer_summary.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=10&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i - 60*60*24}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        # puts "graph: 5 - maturation days offers summary"
      end
    )
    # # open issues
    # threads.push(
    #   Thread.new do
    #     open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_open_issues.png", 'wb') do |file|
    #       file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=12&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
    #     end
    #     # puts "graph: 6 - open issues"
    #   end
    # )
    # closed issues
    threads.push(
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_closed_issues.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=13&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        # puts "graph: 7 - closed issues"
      end
    )
    # issue resolution efficiency
    threads.push(
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_issue_resolution_efficiency.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=16&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        # puts "graph: 8 - issue resolution efficiency"
      end
    )
    # open issue age
    threads.push(
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_open_issue_age.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=14&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        # puts "graph: 9 - open issue age"
      end
    )
    # first response days
    threads.push(
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_first_response_days.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=15&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        # puts "graph: 10 - first response days"
      end
    )
    # issue resolution days
    threads.push(
      Thread.new do
        open("./#{TS.graph_file_for_webapp_public}#{project_uuid}_issue_resolution_days.png", 'wb') do |file|
          file << open("http://127.0.0.1:3030/render/d-solo/Ijarcnomz/test-environment?orgId=1&panelId=17&var-project=#{project_uuid}&from=#{BugmTime.now.to_i - TS.graph_time_window_seconds}000&to=#{BugmTime.now.to_i}000&width=#{@graph_size_width}&height=#{@graph_size_height}&tz=UTC-05%3A00").read
        end
        puts "graph: 11 - issue resolution days"
      end
    )
    # wait until pictures for this project are stored before going to the next project
    threads.each(&:join)
  end
  @getting_graph_pictures = false

end

loop do
  # always check the workqueue
  workqueue_sync
  # if nightly needs to be run, run it
  if @nightly_run <= Time.now
    nightly_scr
  end
  # get graphs, but don't wait for them
  Thread.new do
    update_graphs
  end
  sleep 2
end

puts 'DONE'
